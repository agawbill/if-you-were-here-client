{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/collection\n */\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport mix from './mix';\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Collection {\n  /**\n   * Creates a new Collection instance.\n   *\n   * @param {Object} [options={}] The options object.\n   * @param {String} [options.idProperty='id'] The name of the property which is considered to identify an item.\n   */\n  constructor(options = {}) {\n    /**\n     * The internal list of items in the collection.\n     *\n     * @private\n     * @member {Object[]}\n     */\n    this._items = [];\n    /**\n     * The internal map of items in the collection.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._itemMap = new Map();\n    /**\n     * The name of the property which is considered to identify an item.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._idProperty = options.idProperty || 'id';\n    /**\n     * A helper mapping external items of a bound collection ({@link #bindTo})\n     * and actual items of this collection. It provides information\n     * necessary to properly remove items bound to another collection.\n     *\n     * See {@link #_bindToInternalToExternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToExternalToInternalMap = new WeakMap();\n    /**\n     * A helper mapping items of this collection to external items of a bound collection\n     * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n     * to avoid loops in two–way bindings.\n     *\n     * See {@link #_bindToExternalToInternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToInternalToExternalMap = new WeakMap();\n    /**\n     * Stores indexes of skipped items from bound external collection.\n     *\n     * @private\n     * @member {Array}\n     */\n\n    this._skippedIndexesFromExternal = [];\n    /**\n     * A collection instance this collection is bound to as a result\n     * of calling {@link #bindTo} method.\n     *\n     * @protected\n     * @member {module:utils/collection~Collection} #_bindToCollection\n     */\n  }\n  /**\n   * The number of items available in the collection.\n   *\n   * @member {Number} #length\n   */\n\n\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Returns the first item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The first item or `null` if collection is empty.\n   */\n\n\n  get first() {\n    return this._items[0] || null;\n  }\n  /**\n   * Returns the last item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The last item or `null` if collection is empty.\n   */\n\n\n  get last() {\n    return this._items[this.length - 1] || null;\n  }\n  /**\n   * Adds an item into the collection.\n   *\n   * If the item does not have an id, then it will be automatically generated and set on the item.\n   *\n   * @chainable\n   * @param {Object} item\n   * @param {Number} [index] The position of the item in the collection. The item\n   * is pushed to the collection when `index` not specified.\n   * @fires add\n   */\n\n\n  add(item, index) {\n    let itemId;\n    const idProperty = this._idProperty;\n\n    if (idProperty in item) {\n      itemId = item[idProperty];\n\n      if (typeof itemId != 'string') {\n        /**\n         * This item's id should be a string.\n         *\n         * @error collection-add-invalid-id\n         */\n        throw new CKEditorError('collection-add-invalid-id', this);\n      }\n\n      if (this.get(itemId)) {\n        /**\n         * This item already exists in the collection.\n         *\n         * @error collection-add-item-already-exists\n         */\n        throw new CKEditorError('collection-add-item-already-exists', this);\n      }\n    } else {\n      item[idProperty] = itemId = uid();\n    } // TODO: Use ES6 default function argument.\n\n\n    if (index === undefined) {\n      index = this._items.length;\n    } else if (index > this._items.length || index < 0) {\n      /**\n       * The index number has invalid value.\n       *\n       * @error collection-add-item-bad-index\n       */\n      throw new CKEditorError('collection-add-item-invalid-index', this);\n    }\n\n    this._items.splice(index, 0, item);\n\n    this._itemMap.set(itemId, item);\n\n    this.fire('add', item, index);\n    return this;\n  }\n  /**\n   * Gets item by its id or index.\n   *\n   * @param {String|Number} idOrIndex The item id or index in the collection.\n   * @returns {Object|null} The requested item or `null` if such item does not exist.\n   */\n\n\n  get(idOrIndex) {\n    let item;\n\n    if (typeof idOrIndex == 'string') {\n      item = this._itemMap.get(idOrIndex);\n    } else if (typeof idOrIndex == 'number') {\n      item = this._items[idOrIndex];\n    } else {\n      /**\n       * Index or id must be given.\n       *\n       * @error collection-get-invalid-arg\n       */\n      throw new CKEditorError('collection-get-invalid-arg: Index or id must be given.', this);\n    }\n\n    return item || null;\n  }\n  /**\n   * Returns a boolean indicating whether the collection contains an item.\n   *\n   * @param {Object|String} itemOrId The item or its id in the collection.\n   * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n   */\n\n\n  has(itemOrId) {\n    if (typeof itemOrId == 'string') {\n      return this._itemMap.has(itemOrId);\n    } else {\n      // Object\n      const idProperty = this._idProperty;\n      const id = itemOrId[idProperty];\n      return this._itemMap.has(id);\n    }\n  }\n  /**\n   * Gets index of item in the collection.\n   * When item is not defined in the collection then index will be equal -1.\n   *\n   * @param {Object|String} itemOrId The item or its id in the collection.\n   * @returns {Number} Index of given item.\n   */\n\n\n  getIndex(itemOrId) {\n    let item;\n\n    if (typeof itemOrId == 'string') {\n      item = this._itemMap.get(itemOrId);\n    } else {\n      item = itemOrId;\n    }\n\n    return this._items.indexOf(item);\n  }\n  /**\n   * Removes an item from the collection.\n   *\n   * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n   * @returns {Object} The removed item.\n   * @fires remove\n   */\n\n\n  remove(subject) {\n    let index, id, item;\n    let itemDoesNotExist = false;\n    const idProperty = this._idProperty;\n\n    if (typeof subject == 'string') {\n      id = subject;\n      item = this._itemMap.get(id);\n      itemDoesNotExist = !item;\n\n      if (item) {\n        index = this._items.indexOf(item);\n      }\n    } else if (typeof subject == 'number') {\n      index = subject;\n      item = this._items[index];\n      itemDoesNotExist = !item;\n\n      if (item) {\n        id = item[idProperty];\n      }\n    } else {\n      item = subject;\n      id = item[idProperty];\n      index = this._items.indexOf(item);\n      itemDoesNotExist = index == -1 || !this._itemMap.get(id);\n    }\n\n    if (itemDoesNotExist) {\n      /**\n       * Item not found.\n       *\n       * @error collection-remove-404\n       */\n      throw new CKEditorError('collection-remove-404: Item not found.', this);\n    }\n\n    this._items.splice(index, 1);\n\n    this._itemMap.delete(id);\n\n    const externalItem = this._bindToInternalToExternalMap.get(item);\n\n    this._bindToInternalToExternalMap.delete(item);\n\n    this._bindToExternalToInternalMap.delete(externalItem);\n\n    this.fire('remove', item, index);\n    return item;\n  }\n  /**\n   * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Array} The result of mapping.\n   */\n\n\n  map(callback, ctx) {\n    return this._items.map(callback, ctx);\n  }\n  /**\n   * Finds the first item in the collection for which the `callback` returns a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Object} The item for which `callback` returned a true value.\n   */\n\n\n  find(callback, ctx) {\n    return this._items.find(callback, ctx);\n  }\n  /**\n   * Returns an array with items for which the `callback` returned a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Object[]} The array with matching items.\n   */\n\n\n  filter(callback, ctx) {\n    return this._items.filter(callback, ctx);\n  }\n  /**\n   * Removes all items from the collection and destroys the binding created using\n   * {@link #bindTo}.\n   */\n\n\n  clear() {\n    if (this._bindToCollection) {\n      this.stopListening(this._bindToCollection);\n      this._bindToCollection = null;\n    }\n\n    while (this.length) {\n      this.remove(0);\n    }\n  }\n  /**\n   * Binds and synchronizes the collection with another one.\n   *\n   * The binding can be a simple factory:\n   *\n   *\t\tclass FactoryClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).as( FactoryClass );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n   *\n   *\t\tsource.remove( 0 );\n   *\t\tconsole.log( target.length ); // 1\n   *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n   *\n   * or the factory driven by a custom callback:\n   *\n   *\t\tclass FooClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tclass BarClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( ( item ) => {\n   *\t\t\tif ( item.label == 'foo' ) {\n   *\t\t\t\treturn new FooClass( item );\n   *\t\t\t} else {\n   *\t\t\t\treturn new BarClass( item );\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n   *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n   *\n   * or the factory out of property name:\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( 'label' );\n   *\n   *\t\tsource.add( { label: { value: 'foo' } } );\n   *\t\tsource.add( { label: { value: 'bar' } } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n   *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n   *\n   * It's possible to skip specified items by returning falsy value:\n   *\n   *\t\tconst source = new Collection();\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( item => {\n   *\t\t\tif ( item.hidden ) {\n   *\t\t\t\treturn null;\n   *\t\t\t}\n   *\n   *\t\t\treturn item;\n   *\t\t} );\n   *\n   *\t\tsource.add( { hidden: true } );\n   *\t\tsource.add( { hidden: false } );\n   *\n   *\t\tconsole.log( source.length ); // 2\n   *\t\tconsole.log( target.length ); // 1\n   *\n   * **Note**: {@link #clear} can be used to break the binding.\n   *\n   * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n   * @returns {Object}\n   * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n   */\n\n\n  bindTo(externalCollection) {\n    if (this._bindToCollection) {\n      /**\n       * The collection cannot be bound more than once.\n       *\n       * @error collection-bind-to-rebind\n       */\n      throw new CKEditorError('collection-bind-to-rebind: The collection cannot be bound more than once.', this);\n    }\n\n    this._bindToCollection = externalCollection;\n    return {\n      as: Class => {\n        this._setUpBindToBinding(item => new Class(item));\n      },\n      using: callbackOrProperty => {\n        if (typeof callbackOrProperty == 'function') {\n          this._setUpBindToBinding(item => callbackOrProperty(item));\n        } else {\n          this._setUpBindToBinding(item => item[callbackOrProperty]);\n        }\n      }\n    };\n  }\n  /**\n   * Finalizes and activates a binding initiated by {#bindTo}.\n   *\n   * @protected\n   * @param {Function} factory A function which produces collection items.\n   */\n\n\n  _setUpBindToBinding(factory) {\n    const externalCollection = this._bindToCollection; // Adds the item to the collection once a change has been done to the external collection.\n    //\n    // @private\n\n    const addItem = (evt, externalItem, index) => {\n      const isExternalBoundToThis = externalCollection._bindToCollection == this;\n\n      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem); // If an external collection is bound to this collection, which makes it a 2–way binding,\n      // and the particular external collection item is already bound, don't add it here.\n      // The external item has been created **out of this collection's item** and (re)adding it will\n      // cause a loop.\n\n\n      if (isExternalBoundToThis && externalItemBound) {\n        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);\n\n        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);\n      } else {\n        const item = factory(externalItem); // When there is no item we need to remember skipped index first and then we can skip this item.\n\n        if (!item) {\n          this._skippedIndexesFromExternal.push(index);\n\n          return;\n        } // Lets try to put item at the same index as index in external collection\n        // but when there are a skipped items in one or both collections we need to recalculate this index.\n\n\n        let finalIndex = index; // When we try to insert item after some skipped items from external collection we need\n        // to include this skipped items and decrease index.\n        //\n        // For the following example:\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n        // internal -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n        //\n        // We can't just add 'D' to internal at the same index as index in external because\n        // this will produce empty indexes what is invalid:\n        // internal -> [ 'A', empty, empty, 'D' ]\n        //\n        // So we need to include skipped items and decrease index\n        // internal -> [ 'A', 'D' ]\n\n        for (const skipped of this._skippedIndexesFromExternal) {\n          if (index > skipped) {\n            finalIndex--;\n          }\n        } // We need to take into consideration that external collection could skip some items from\n        // internal collection.\n        //\n        // For the following example:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n        // external -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'D' ]\n        //\n        // We need to include skipped items and place new item after them:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\n\n        for (const skipped of externalCollection._skippedIndexesFromExternal) {\n          if (finalIndex >= skipped) {\n            finalIndex++;\n          }\n        }\n\n        this._bindToExternalToInternalMap.set(externalItem, item);\n\n        this._bindToInternalToExternalMap.set(item, externalItem);\n\n        this.add(item, finalIndex); // After adding new element to internal collection we need update indexes\n        // of skipped items in external collection.\n\n        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {\n          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {\n            externalCollection._skippedIndexesFromExternal[i]++;\n          }\n        }\n      }\n    }; // Load the initial content of the collection.\n\n\n    for (const externalItem of externalCollection) {\n      addItem(null, externalItem, externalCollection.getIndex(externalItem));\n    } // Synchronize the with collection as new items are added.\n\n\n    this.listenTo(externalCollection, 'add', addItem); // Synchronize the with collection as new items are removed.\n\n    this.listenTo(externalCollection, 'remove', (evt, externalItem, index) => {\n      const item = this._bindToExternalToInternalMap.get(externalItem);\n\n      if (item) {\n        this.remove(item);\n      } // After removing element from external collection we need update/remove indexes\n      // of skipped items in internal collection.\n\n\n      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {\n        if (index < skipped) {\n          result.push(skipped - 1);\n        }\n\n        if (index > skipped) {\n          result.push(skipped);\n        }\n\n        return result;\n      }, []);\n    });\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._items[Symbol.iterator]();\n  }\n  /**\n   * Fired when an item is added to the collection.\n   *\n   * @event add\n   * @param {Object} item The added item.\n   */\n\n  /**\n   * Fired when an item is removed from the collection.\n   *\n   * @event remove\n   * @param {Object} item The removed item.\n   * @param {Number} index Index from which item was removed.\n   */\n\n\n}\nmix(Collection, EmitterMixin);\n/**\n * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method\n * providing functions that specify the type of the binding.\n *\n * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.\n *\n * @interface module:utils/collection~CollectionBindToChain\n */\n\n/**\n * Creates a callback or a property binding.\n *\n * @method #using\n * @param {Function|String} callbackOrProperty  When the function is passed, it should return\n * the collection items. When the string is provided, the property value is used to create the bound collection items.\n */\n\n/**\n * Creates the class factory binding in which items of the source collection are passed to\n * the constructor of the specified class.\n *\n * @method #as\n * @param {Function} Class The class constructor used to create instances in the factory.\n */","map":{"version":3,"sources":["/home/anthony/Desktop/if-you-were-here/node_modules/@ckeditor/ckeditor5-utils/src/collection.js"],"names":["EmitterMixin","CKEditorError","uid","mix","Collection","constructor","options","_items","_itemMap","Map","_idProperty","idProperty","_bindToExternalToInternalMap","WeakMap","_bindToInternalToExternalMap","_skippedIndexesFromExternal","length","first","last","add","item","index","itemId","get","undefined","splice","set","fire","idOrIndex","has","itemOrId","id","getIndex","indexOf","remove","subject","itemDoesNotExist","delete","externalItem","map","callback","ctx","find","filter","clear","_bindToCollection","stopListening","bindTo","externalCollection","as","Class","_setUpBindToBinding","using","callbackOrProperty","factory","addItem","evt","isExternalBoundToThis","externalItemBound","push","finalIndex","skipped","i","listenTo","reduce","result","Symbol","iterator"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/collection\n */\n\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport mix from './mix';\n\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Collection {\n\t/**\n\t * Creates a new Collection instance.\n\t *\n\t * @param {Object} [options={}] The options object.\n\t * @param {String} [options.idProperty='id'] The name of the property which is considered to identify an item.\n\t */\n\tconstructor( options = {} ) {\n\t\t/**\n\t\t * The internal list of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Object[]}\n\t\t */\n\t\tthis._items = [];\n\n\t\t/**\n\t\t * The internal map of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._itemMap = new Map();\n\n\t\t/**\n\t\t * The name of the property which is considered to identify an item.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._idProperty = options.idProperty || 'id';\n\n\t\t/**\n\t\t * A helper mapping external items of a bound collection ({@link #bindTo})\n\t\t * and actual items of this collection. It provides information\n\t\t * necessary to properly remove items bound to another collection.\n\t\t *\n\t\t * See {@link #_bindToInternalToExternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToExternalToInternalMap = new WeakMap();\n\n\t\t/**\n\t\t * A helper mapping items of this collection to external items of a bound collection\n\t\t * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n\t\t * to avoid loops in two–way bindings.\n\t\t *\n\t\t * See {@link #_bindToExternalToInternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToInternalToExternalMap = new WeakMap();\n\n\t\t/**\n\t\t * Stores indexes of skipped items from bound external collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Array}\n\t\t */\n\t\tthis._skippedIndexesFromExternal = [];\n\n\t\t/**\n\t\t * A collection instance this collection is bound to as a result\n\t\t * of calling {@link #bindTo} method.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:utils/collection~Collection} #_bindToCollection\n\t\t */\n\t}\n\n\t/**\n\t * The number of items available in the collection.\n\t *\n\t * @member {Number} #length\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * Returns the first item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The first item or `null` if collection is empty.\n\t */\n\tget first() {\n\t\treturn this._items[ 0 ] || null;\n\t}\n\n\t/**\n\t * Returns the last item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The last item or `null` if collection is empty.\n\t */\n\tget last() {\n\t\treturn this._items[ this.length - 1 ] || null;\n\t}\n\n\t/**\n\t * Adds an item into the collection.\n\t *\n\t * If the item does not have an id, then it will be automatically generated and set on the item.\n\t *\n\t * @chainable\n\t * @param {Object} item\n\t * @param {Number} [index] The position of the item in the collection. The item\n\t * is pushed to the collection when `index` not specified.\n\t * @fires add\n\t */\n\tadd( item, index ) {\n\t\tlet itemId;\n\t\tconst idProperty = this._idProperty;\n\n\t\tif ( ( idProperty in item ) ) {\n\t\t\titemId = item[ idProperty ];\n\n\t\t\tif ( typeof itemId != 'string' ) {\n\t\t\t\t/**\n\t\t\t\t * This item's id should be a string.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-invalid-id\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-invalid-id', this );\n\t\t\t}\n\n\t\t\tif ( this.get( itemId ) ) {\n\t\t\t\t/**\n\t\t\t\t * This item already exists in the collection.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-item-already-exists\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-item-already-exists', this );\n\t\t\t}\n\t\t} else {\n\t\t\titem[ idProperty ] = itemId = uid();\n\t\t}\n\n\t\t// TODO: Use ES6 default function argument.\n\t\tif ( index === undefined ) {\n\t\t\tindex = this._items.length;\n\t\t} else if ( index > this._items.length || index < 0 ) {\n\t\t\t/**\n\t\t\t * The index number has invalid value.\n\t\t\t *\n\t\t\t * @error collection-add-item-bad-index\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-add-item-invalid-index', this );\n\t\t}\n\n\t\tthis._items.splice( index, 0, item );\n\n\t\tthis._itemMap.set( itemId, item );\n\n\t\tthis.fire( 'add', item, index );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets item by its id or index.\n\t *\n\t * @param {String|Number} idOrIndex The item id or index in the collection.\n\t * @returns {Object|null} The requested item or `null` if such item does not exist.\n\t */\n\tget( idOrIndex ) {\n\t\tlet item;\n\n\t\tif ( typeof idOrIndex == 'string' ) {\n\t\t\titem = this._itemMap.get( idOrIndex );\n\t\t} else if ( typeof idOrIndex == 'number' ) {\n\t\t\titem = this._items[ idOrIndex ];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Index or id must be given.\n\t\t\t *\n\t\t\t * @error collection-get-invalid-arg\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-get-invalid-arg: Index or id must be given.', this );\n\t\t}\n\n\t\treturn item || null;\n\t}\n\n\t/**\n\t * Returns a boolean indicating whether the collection contains an item.\n\t *\n\t * @param {Object|String} itemOrId The item or its id in the collection.\n\t * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n\t */\n\thas( itemOrId ) {\n\t\tif ( typeof itemOrId == 'string' ) {\n\t\t\treturn this._itemMap.has( itemOrId );\n\t\t} else { // Object\n\t\t\tconst idProperty = this._idProperty;\n\t\t\tconst id = itemOrId[ idProperty ];\n\n\t\t\treturn this._itemMap.has( id );\n\t\t}\n\t}\n\n\t/**\n\t * Gets index of item in the collection.\n\t * When item is not defined in the collection then index will be equal -1.\n\t *\n\t * @param {Object|String} itemOrId The item or its id in the collection.\n\t * @returns {Number} Index of given item.\n\t */\n\tgetIndex( itemOrId ) {\n\t\tlet item;\n\n\t\tif ( typeof itemOrId == 'string' ) {\n\t\t\titem = this._itemMap.get( itemOrId );\n\t\t} else {\n\t\t\titem = itemOrId;\n\t\t}\n\n\t\treturn this._items.indexOf( item );\n\t}\n\n\t/**\n\t * Removes an item from the collection.\n\t *\n\t * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n\t * @returns {Object} The removed item.\n\t * @fires remove\n\t */\n\tremove( subject ) {\n\t\tlet index, id, item;\n\t\tlet itemDoesNotExist = false;\n\t\tconst idProperty = this._idProperty;\n\n\t\tif ( typeof subject == 'string' ) {\n\t\t\tid = subject;\n\t\t\titem = this._itemMap.get( id );\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tindex = this._items.indexOf( item );\n\t\t\t}\n\t\t} else if ( typeof subject == 'number' ) {\n\t\t\tindex = subject;\n\t\t\titem = this._items[ index ];\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tid = item[ idProperty ];\n\t\t\t}\n\t\t} else {\n\t\t\titem = subject;\n\t\t\tid = item[ idProperty ];\n\t\t\tindex = this._items.indexOf( item );\n\t\t\titemDoesNotExist = ( index == -1 || !this._itemMap.get( id ) );\n\t\t}\n\n\t\tif ( itemDoesNotExist ) {\n\t\t\t/**\n\t\t\t * Item not found.\n\t\t\t *\n\t\t\t * @error collection-remove-404\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-remove-404: Item not found.', this );\n\t\t}\n\n\t\tthis._items.splice( index, 1 );\n\t\tthis._itemMap.delete( id );\n\n\t\tconst externalItem = this._bindToInternalToExternalMap.get( item );\n\t\tthis._bindToInternalToExternalMap.delete( item );\n\t\tthis._bindToExternalToInternalMap.delete( externalItem );\n\n\t\tthis.fire( 'remove', item, index );\n\n\t\treturn item;\n\t}\n\n\t/**\n\t * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Array} The result of mapping.\n\t */\n\tmap( callback, ctx ) {\n\t\treturn this._items.map( callback, ctx );\n\t}\n\n\t/**\n\t * Finds the first item in the collection for which the `callback` returns a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Object} The item for which `callback` returned a true value.\n\t */\n\tfind( callback, ctx ) {\n\t\treturn this._items.find( callback, ctx );\n\t}\n\n\t/**\n\t * Returns an array with items for which the `callback` returned a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Object[]} The array with matching items.\n\t */\n\tfilter( callback, ctx ) {\n\t\treturn this._items.filter( callback, ctx );\n\t}\n\n\t/**\n\t * Removes all items from the collection and destroys the binding created using\n\t * {@link #bindTo}.\n\t */\n\tclear() {\n\t\tif ( this._bindToCollection ) {\n\t\t\tthis.stopListening( this._bindToCollection );\n\t\t\tthis._bindToCollection = null;\n\t\t}\n\n\t\twhile ( this.length ) {\n\t\t\tthis.remove( 0 );\n\t\t}\n\t}\n\n\t/**\n\t * Binds and synchronizes the collection with another one.\n\t *\n\t * The binding can be a simple factory:\n\t *\n\t *\t\tclass FactoryClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).as( FactoryClass );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n\t *\n\t *\t\tsource.remove( 0 );\n\t *\t\tconsole.log( target.length ); // 1\n\t *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n\t *\n\t * or the factory driven by a custom callback:\n\t *\n\t *\t\tclass FooClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tclass BarClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( ( item ) => {\n\t *\t\t\tif ( item.label == 'foo' ) {\n\t *\t\t\t\treturn new FooClass( item );\n\t *\t\t\t} else {\n\t *\t\t\t\treturn new BarClass( item );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n\t *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n\t *\n\t * or the factory out of property name:\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( 'label' );\n\t *\n\t *\t\tsource.add( { label: { value: 'foo' } } );\n\t *\t\tsource.add( { label: { value: 'bar' } } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n\t *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n\t *\n\t * It's possible to skip specified items by returning falsy value:\n\t *\n\t *\t\tconst source = new Collection();\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( item => {\n\t *\t\t\tif ( item.hidden ) {\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn item;\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { hidden: true } );\n\t *\t\tsource.add( { hidden: false } );\n\t *\n\t *\t\tconsole.log( source.length ); // 2\n\t *\t\tconsole.log( target.length ); // 1\n\t *\n\t * **Note**: {@link #clear} can be used to break the binding.\n\t *\n\t * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n\t * @returns {Object}\n\t * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n\t */\n\tbindTo( externalCollection ) {\n\t\tif ( this._bindToCollection ) {\n\t\t\t/**\n\t\t\t * The collection cannot be bound more than once.\n\t\t\t *\n\t\t\t * @error collection-bind-to-rebind\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-bind-to-rebind: The collection cannot be bound more than once.', this );\n\t\t}\n\n\t\tthis._bindToCollection = externalCollection;\n\n\t\treturn {\n\t\t\tas: Class => {\n\t\t\t\tthis._setUpBindToBinding( item => new Class( item ) );\n\t\t\t},\n\n\t\t\tusing: callbackOrProperty => {\n\t\t\t\tif ( typeof callbackOrProperty == 'function' ) {\n\t\t\t\t\tthis._setUpBindToBinding( item => callbackOrProperty( item ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis._setUpBindToBinding( item => item[ callbackOrProperty ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Finalizes and activates a binding initiated by {#bindTo}.\n\t *\n\t * @protected\n\t * @param {Function} factory A function which produces collection items.\n\t */\n\t_setUpBindToBinding( factory ) {\n\t\tconst externalCollection = this._bindToCollection;\n\n\t\t// Adds the item to the collection once a change has been done to the external collection.\n\t\t//\n\t\t// @private\n\t\tconst addItem = ( evt, externalItem, index ) => {\n\t\t\tconst isExternalBoundToThis = externalCollection._bindToCollection == this;\n\t\t\tconst externalItemBound = externalCollection._bindToInternalToExternalMap.get( externalItem );\n\n\t\t\t// If an external collection is bound to this collection, which makes it a 2–way binding,\n\t\t\t// and the particular external collection item is already bound, don't add it here.\n\t\t\t// The external item has been created **out of this collection's item** and (re)adding it will\n\t\t\t// cause a loop.\n\t\t\tif ( isExternalBoundToThis && externalItemBound ) {\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, externalItemBound );\n\t\t\t\tthis._bindToInternalToExternalMap.set( externalItemBound, externalItem );\n\t\t\t} else {\n\t\t\t\tconst item = factory( externalItem );\n\n\t\t\t\t// When there is no item we need to remember skipped index first and then we can skip this item.\n\t\t\t\tif ( !item ) {\n\t\t\t\t\tthis._skippedIndexesFromExternal.push( index );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Lets try to put item at the same index as index in external collection\n\t\t\t\t// but when there are a skipped items in one or both collections we need to recalculate this index.\n\t\t\t\tlet finalIndex = index;\n\n\t\t\t\t// When we try to insert item after some skipped items from external collection we need\n\t\t\t\t// to include this skipped items and decrease index.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n\t\t\t\t// internal -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We can't just add 'D' to internal at the same index as index in external because\n\t\t\t\t// this will produce empty indexes what is invalid:\n\t\t\t\t// internal -> [ 'A', empty, empty, 'D' ]\n\t\t\t\t//\n\t\t\t\t// So we need to include skipped items and decrease index\n\t\t\t\t// internal -> [ 'A', 'D' ]\n\t\t\t\tfor ( const skipped of this._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\t\tfinalIndex--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration that external collection could skip some items from\n\t\t\t\t// internal collection.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n\t\t\t\t// external -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We need to include skipped items and place new item after them:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\t\t\t\tfor ( const skipped of externalCollection._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( finalIndex >= skipped ) {\n\t\t\t\t\t\tfinalIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, item );\n\t\t\t\tthis._bindToInternalToExternalMap.set( item, externalItem );\n\t\t\t\tthis.add( item, finalIndex );\n\n\t\t\t\t// After adding new element to internal collection we need update indexes\n\t\t\t\t// of skipped items in external collection.\n\t\t\t\tfor ( let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++ ) {\n\t\t\t\t\tif ( finalIndex <= externalCollection._skippedIndexesFromExternal[ i ] ) {\n\t\t\t\t\t\texternalCollection._skippedIndexesFromExternal[ i ]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Load the initial content of the collection.\n\t\tfor ( const externalItem of externalCollection ) {\n\t\t\taddItem( null, externalItem, externalCollection.getIndex( externalItem ) );\n\t\t}\n\n\t\t// Synchronize the with collection as new items are added.\n\t\tthis.listenTo( externalCollection, 'add', addItem );\n\n\t\t// Synchronize the with collection as new items are removed.\n\t\tthis.listenTo( externalCollection, 'remove', ( evt, externalItem, index ) => {\n\t\t\tconst item = this._bindToExternalToInternalMap.get( externalItem );\n\n\t\t\tif ( item ) {\n\t\t\t\tthis.remove( item );\n\t\t\t}\n\n\t\t\t// After removing element from external collection we need update/remove indexes\n\t\t\t// of skipped items in internal collection.\n\t\t\tthis._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce( ( result, skipped ) => {\n\t\t\t\tif ( index < skipped ) {\n\t\t\t\t\tresult.push( skipped - 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\tresult.push( skipped );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [] );\n\t\t} );\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Fired when an item is added to the collection.\n\t *\n\t * @event add\n\t * @param {Object} item The added item.\n\t */\n\n\t/**\n\t * Fired when an item is removed from the collection.\n\t *\n\t * @event remove\n\t * @param {Object} item The removed item.\n\t * @param {Number} index Index from which item was removed.\n\t */\n}\n\nmix( Collection, EmitterMixin );\n\n/**\n * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method\n * providing functions that specify the type of the binding.\n *\n * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.\n *\n * @interface module:utils/collection~CollectionBindToChain\n */\n\n/**\n * Creates a callback or a property binding.\n *\n * @method #using\n * @param {Function|String} callbackOrProperty  When the function is passed, it should return\n * the collection items. When the string is provided, the property value is used to create the bound collection items.\n */\n\n/**\n * Creates the class factory binding in which items of the source collection are passed to\n * the constructor of the specified class.\n *\n * @method #as\n * @param {Function} Class The class constructor used to create instances in the factory.\n */\n"]},"metadata":{},"sourceType":"module"}